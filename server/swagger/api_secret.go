/*
 * Secret Server
 *
 * This is an API of a secret service. You can save your secret by using the API. You can restrict the access of a secret after the certen number of views or after a certen period of time.
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"log"
	"net/http"
	"strconv"
	"time"

	"example.com/secrets"
	"github.com/gorilla/mux"
)

func AddSecret(UploadedSecret *secrets.AllSecrets) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		defer log.Printf(
			"%s %s %s",
			r.Method,
			r.RequestURI,
			time.Since(start),
		)

		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		defer r.Body.Close()

		// load data and check if it's correct
		err := r.ParseForm()
		if err != nil {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}
		ExpireAfterViews, err := strconv.Atoi(r.Form.Get("expireAfterViews"))
		if err != nil || int32(ExpireAfterViews) <= 0 {
			//SendError(w, errors.New("expireAfterViews: must be integer greater than zero"))
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}
		ExpireAfterTime, err := strconv.Atoi(r.Form.Get("expireAfter"))
		if err != nil || int32(ExpireAfterTime) < 0 {
			//SendError(w, errors.New("expireAfter: must be integer greater or eqcual zero"))
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}

		// convert loaded data to struct Secret and put it pointer in map and priorityqueue
		SecretText := r.Form.Get("secret")
		secret, err := secrets.CreateSecret(UploadedSecret, SecretText, int32(ExpireAfterViews), int32(ExpireAfterTime))
		if err != nil {
			log.Println(err)
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}

		// convert to json and write response
		secrets.WriteSecret(w, secret)
	}
}

func GetSecretByHashfunc(UploadedSecret *secrets.AllSecrets) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		defer log.Printf(
			"%s %s %s",
			r.Method,
			r.RequestURI,
			time.Since(start),
		)
		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		defer r.Body.Close()

		// delete all expired secrets by time
		CrrTime := time.Now()
		secrets.DeleteExpired(UploadedSecret, CrrTime)

		vars := mux.Vars(r)
		secrets.FindSecret(UploadedSecret, w, vars["hash"])
	}
}
